

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diag.convergence_tools &mdash; ThemisPy 0+untagged.178.gc5e8489.dirty documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="ThemisPy 0+untagged.178.gc5e8489.dirty documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../docs/src/index.html" class="icon icon-home"> ThemisPy
          

          
          </a>

          
            
            
              <div class="version">
                0+untagged.178.gc5e8489.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../docs/src/installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/src/userguide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/src/devel.html">Developer’s Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../docs/src/index.html">ThemisPy</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../docs/src/index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>diag.convergence_tools</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diag.convergence_tools</h1><div class="highlight"><pre>
<span></span><span class="c1">###########################</span>
<span class="c1">#</span>
<span class="c1"># Package:</span>
<span class="c1">#   convergence_tools</span>
<span class="c1">#</span>
<span class="c1"># Provides:</span>
<span class="c1">#   Functions for computing convergence diagonstics of MCMC chains produced by Themis.</span>
<span class="c1">#   </span>

<span class="kn">from</span> <span class="nn">themispy.utils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">themispy</span> <span class="kn">import</span> <span class="n">chain</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The autocorrelation stuff has been taken from EMCEE article on IACT</span>
<span class="sd">for the ensemble samplers. In the future I will probably switch to the IACT formula from BDA3.</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="next_pow_two"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.next_pow_two">[docs]</a><span class="k">def</span> <span class="nf">next_pow_two</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the value of 2**n, following `emcee &lt;https://emcee.readthedocs.io/en/stable/tutorials/autocorr&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">      n (int): Power of 2</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">      (int): Value of 2**n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="autocorr_func_1d"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.autocorr_func_1d">[docs]</a><span class="k">def</span> <span class="nf">autocorr_func_1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the 1D autocorrelation function of a sequences, following </span>
<span class="sd">    `emcee &lt;https://emcee.readthedocs.io/en/stable/tutorials/autocorr&gt;`_.  </span>
<span class="sd">    This is done via FFT, and thus assumes that the sequences is stationary.</span>

<span class="sd">    Args:</span>
<span class="sd">      x (numpy.ndarray): A sequence of values.</span>
<span class="sd">      norm (bool): If true normalizes the autocorrelation by the variance. Otherwise the zero-lag component of the autocorrelation function is the variance. Default: True.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarra): Autocorrlation function appropriately normalized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for 1D autocorrelation function&quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">next_pow_two</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># Compute the FFT and then (from that) the auto-correlation function</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">f</span><span class="p">))[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">real</span>
    <span class="n">acf</span> <span class="o">/=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># Optionally normalize</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">acf</span> <span class="o">/=</span> <span class="n">acf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">acf</span></div>


<span class="c1"># Automated windowing procedure following Sokal (1989)</span>
<div class="viewcode-block" id="auto_window"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.auto_window">[docs]</a><span class="k">def</span> <span class="nf">auto_window</span><span class="p">(</span><span class="n">taus</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatic windowing procedure following `emcee &lt;https://emcee.readthedocs.io/en/stable/tutorials/autocorr&gt;`_, which follows `Sokal (1989) &lt;https://pdfs.semanticscholar.org/0bfe/9e3db30605fe2d4d26e1a288a5e2997e7225.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">      taus (numpy.ndarray): Estimates of the integrated autocorrelation time (IACT).</span>
<span class="sd">      c (float): Sokal factor, with an optimal value approximately of 5.0.  Default: 5.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (int): Index of minimum window for computing the autocorrelation time?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taus</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">*</span> <span class="n">taus</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">taus</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="ensemble_autocorr"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.ensemble_autocorr">[docs]</a><span class="k">def</span> <span class="nf">ensemble_autocorr</span><span class="p">(</span><span class="n">param_chain</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the integrated autocorrelation time for the chain, following `emcee &lt;https://emcee.readthedocs.io/en/stable/tutorials/autocorr&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">      param_chain (numpy.ndarray): Ensemble MCMC chain for a single parameters, arranged as walkers,steps.</span>
<span class="sd">      c (float): Sokal factor, with an optimal value approximately of 5.0.  Default: 5.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (float): Integrated autocorrelation time (IACT).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param_chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="n">param_chain</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">autocorr_func_1d</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_chain</span><span class="p">)</span>
    <span class="n">taus</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">auto_window</span><span class="p">(</span><span class="n">taus</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">iac</span> <span class="o">=</span> <span class="n">taus</span><span class="p">[</span><span class="n">window</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iac</span><span class="o">*</span><span class="mi">50</span> <span class="o">&gt;</span> <span class="n">param_chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: In order to get decent estimate of the integrated autocorrelation time (IAC), IAC*50 &lt; number of steps. You should really run the chain longer!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iac</span></div>

<div class="viewcode-block" id="mean_ess"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.mean_ess">[docs]</a><span class="k">def</span> <span class="nf">mean_ess</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the average ESS across chains by dividing the number of steps by the IAC.</span>
<span class="sd">    Note the actual ESS of the entire chain and walkers is greater than this, but likely isn&#39;t</span>
<span class="sd">    the number of walkers * mean_ess since the chains are correlated.</span>

<span class="sd">    Args:</span>
<span class="sd">      y (numpy.ndarray): Ensemble MCMC chain for a single parameters, arranged as walkers,steps.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (float): Average number of ensemble samples across chains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">ensemble_autocorr</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="mean_echain"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.mean_echain">[docs]</a><span class="k">def</span> <span class="nf">mean_echain</span><span class="p">(</span><span class="n">echain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the average of the ensemble chain for each step. That is, </span>
<span class="sd">    we average over the walkers at each step converting the chain into a</span>
<span class="sd">    single particle chain of the average.</span>

<span class="sd">    Args:</span>
<span class="sd">      echain (numpy.ndarray): Ensemble MCMC chain, generated, e.g., from :func:`chain.mcmc_chain.read_echain`.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): Chain data arranged as 2D array indexed by [sample, parameter] *after* averaging over walkers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">echain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="var_echain"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.var_echain">[docs]</a><span class="k">def</span> <span class="nf">var_echain</span><span class="p">(</span><span class="n">echain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the variance of the echain for each step. That is, we compute the</span>
<span class="sd">    variance of the walkers at each step, converting the chain into a single </span>
<span class="sd">    particle chain of the variance between chains.</span>

<span class="sd">    Args:</span>
<span class="sd">      echain (numpy.ndarray): Ensemble chain data, generated, e.g., from :func:`chain.mcmc_chain.read_echain`.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): Variance of chain data arranged as 2D array indexed by [sample, parameter] *after* computing the variance over walkers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">echain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="ranknormalized_chains"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.ranknormalized_chains">[docs]</a><span class="k">def</span> <span class="nf">ranknormalized_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rank-normalized chains, where the rank is taken over all the chains.</span>
<span class="sd">    This allows :math:`\\hat{R}` to be used when we the distribution might not have a finite</span>
<span class="sd">    mean or variance.</span>

<span class="sd">    Returns the rank normalized chains, i.e. the z-scores and the actual ranks.</span>

<span class="sd">    Args:</span>
<span class="sd">      chains (list): List of chains, stored as 2D arrays indexed by [sample,parameter].</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray, numpy.ndarray): Array of probability densities associated with given rank; Array of ranks for each parameter value.  Both are provided in the *same* order as the original data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chainsary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">chains</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ranks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chainsary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">chainsary</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">chainsary</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="n">rank</span> <span class="o">-</span> <span class="mf">3.0</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">))</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">zz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chainsary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>
        <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rank</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chainsary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ranks</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="fold_chains"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.fold_chains">[docs]</a><span class="k">def</span> <span class="nf">fold_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the chain folded around the median of all the chains, i.e., for each</span>
<span class="sd">    parameter :math:`p`, every chain sample is replaced with :math:`|p-\\bar{p}|` </span>
<span class="sd">    where :math:`\\bar{p}` is the median across all chains.</span>
<span class="sd">    This helps with measuring :math:`\\hat{R}` in the tails.</span>

<span class="sd">    Args:</span>
<span class="sd">      chains (numpy.ndarray): A single walker chain arranged as a 3D array indexed by [runs, samples, parameters].</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): Folded single walker chain arranged as 3D array index by [runs, samples, parameters].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Chains must have 3 dimensions not &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;. If ndim=4, you are probably passing an ensemble chain. In that case, please take the expectation over the walkers.&quot;</span>
    <span class="n">flatchains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">chains</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">chains</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flatchains</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flatchains</span><span class="o">-</span><span class="n">median</span><span class="p">),</span> <span class="n">chains</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="bulk_split_rhat"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.bulk_split_rhat">[docs]</a><span class="k">def</span> <span class="nf">bulk_split_rhat</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the bulk :math:`\\hat{R}` using rank normalized chains. The returned value is the </span>
<span class="sd">    maximum of the folded :math:`\\hat{R}` and regular rank normalized :math:`\\hat{R}` as recommended in </span>
<span class="sd">    `Vehtari (2019) &lt;https://ui.adsabs.harvard.edu/abs/2019arXiv190308008V/abstract&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">      chains (numpy.ndarray): A single walker chain arranged as a 3D array indexed by [runs, samples, parameters].</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): An array of values of the split :math:`\\hat{R}` statistic from `Gelman (2013) &lt;http://www.stat.columbia.edu/~gelman/book/&gt;`_ for each parameter in the chain using rank-normalized values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">assert</span> <span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Chains must have 3 dimensions not &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;. If ndim=4, you are probably passing an ensemble chain. In that case, please take the expectation over the walkers.&quot;</span>
    <span class="n">z</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">ranknormalized_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">)</span>
    <span class="n">zfold</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">ranknormalized_chains</span><span class="p">(</span><span class="n">fold_chains</span><span class="p">(</span><span class="n">chains</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">split_rhat</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">split_rhat</span><span class="p">(</span><span class="n">zfold</span><span class="p">))</span></div>


<div class="viewcode-block" id="split_rhat"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.split_rhat">[docs]</a><span class="k">def</span> <span class="nf">split_rhat</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the split :math:`\\hat{R}` statistic from </span>
<span class="sd">    `Gelman (2013) &lt;http://www.stat.columbia.edu/~gelman/book/&gt;`_. This is able to </span>
<span class="sd">    deal with distributions that don&#39;t have finite mean and/or variance. Additionally, </span>
<span class="sd">    it splits the chain in two in order to check if the beginning and end of the chain </span>
<span class="sd">    have similar variance to check for intrachain convergence.</span>

<span class="sd">    Args:</span>
<span class="sd">      chains (numpy.ndarray): A single walker chain arranged as a 3D array indexed by [runs, samples, parameters].</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): An array of values of the split :math:`\\hat{R}` statistic from `Gelman (2013) &lt;http://www.stat.columbia.edu/~gelman/book/&gt;`_ for each parameter in the chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Chains must have 3 dimensions not &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">chains</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;. If ndim=4, you are probably passing an ensemble chain. In that case, please take the expectation over the walkers.&quot;</span>
    <span class="n">chains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chains</span><span class="p">)</span>
    <span class="n">chain_maj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">chain_maj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">chain_maj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_rhat</span><span class="p">(</span><span class="n">chain_maj</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_rhat</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function</span>
<span class="sd">    Computes the :math:`\\hat{R}` between the chains. This only assumes that we are using a single</span>
<span class="sd">    chain. If using an ensemble method please first convert it into a single chain by </span>
<span class="sd">    taking the expectation of a function, i.e. a mean, across the walkers.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">chains</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1">#Average over each chain, so we have the average for each chain</span>
    <span class="n">avg_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">#Average over both</span>
    <span class="n">avg_nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">avg_n</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#Now calculate the between chain variance</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">avg_n</span><span class="o">*</span><span class="n">avg_n</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">avg_nm</span><span class="o">*</span><span class="n">avg_nm</span><span class="o">*</span><span class="n">M</span><span class="p">)</span>

    <span class="c1">#Now calculate the within chain variance</span>
    <span class="n">s2m</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chains</span><span class="o">*</span><span class="n">chains</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">avg_n</span><span class="o">*</span><span class="n">avg_n</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s2m</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">marginal_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="n">W</span> <span class="o">+</span> <span class="n">B</span><span class="o">/</span><span class="n">N</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">marginal_var</span><span class="o">/</span><span class="n">W</span><span class="p">)</span>


<div class="viewcode-block" id="find_eautocorr"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.find_eautocorr">[docs]</a><span class="k">def</span> <span class="nf">find_eautocorr</span><span class="p">(</span><span class="n">echain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds and returns the integrated autocorrelation time (IACT) for each parameter </span>
<span class="sd">    in the ensemble chain.</span>

<span class="sd">    Args:</span>
<span class="sd">      echain (numpy.ndarray): Ensemble MCMC chain, generated, e.g., from :func:`chain.mcmc_chain.read_echain`.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (numpy.ndarray): Array of autocorrelation times for each parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">iact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">echain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">echain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">iact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensemble_autocorr</span><span class="p">(</span><span class="n">echain</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iact</span></div>


<div class="viewcode-block" id="save_ensemble_diagnostics"><a class="viewcode-back" href="../../docs/src/diag.html#diag.convergence_tools.save_ensemble_diagnostics">[docs]</a><span class="k">def</span> <span class="nf">save_ensemble_diagnostics</span><span class="p">(</span><span class="n">out_file_name</span><span class="p">,</span> <span class="n">chains</span><span class="p">,</span> <span class="n">chainsname</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rank&quot;</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Outputs the diagnostics of the multiple chains in `chains` to the out file, </span>
<span class="sd">    where the chain is kept track of in `chainsname`. Currently it only outputs </span>
<span class="sd">    the chains integrated autocorrelation time for each parameter. Eventually </span>
<span class="sd">    other diagnostics will be included, such as the </span>
<span class="sd">    `Gelman-Rubin &lt;https://ui.adsabs.harvard.edu/abs/1992StaSc...7..457G/abstract&gt;`_ </span>
<span class="sd">    diagnostic, i.e. split-:math:`\\hat{R}`, and ESS. Currently the default method for </span>
<span class="sd">    :math:`\\hat{R}` is the rank method from</span>
<span class="sd">    `Vehtari (2019) &lt;https://ui.adsabs.harvard.edu/abs/2019arXiv190308008V/abstract&gt;`_.</span>

<span class="sd">    Note that if the integrated autocorrelation time (IACT) is &quot;significantly different&quot; </span>
<span class="sd">    between chains, then at least one of the chains is not converged.</span>

<span class="sd">    Args:</span>
<span class="sd">      out_file_name (str): Name of file to which to output results.</span>
<span class="sd">      chains (list): List of chains for which to compute diagnostics.</span>
<span class="sd">      chainsname (list): List of names (str) of chains for output.</span>
<span class="sd">      method (str): CURRENTLY UNUSED</span>
<span class="sd">      stride (int): Factor by which the chains have been thinned by.  Default: 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;outputting to&quot;</span><span class="p">,</span> <span class="n">out_file_name</span><span class="p">)</span>
    <span class="n">io</span> <span class="o">=</span>  <span class="nb">open</span><span class="p">(</span><span class="n">out_file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;IACT:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">row_fmt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&gt;15}</span><span class="s2">&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; </span><span class="si">{:&lt;25}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">row_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;p&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span> <span class="s2">&quot;filename&quot;</span><span class="p">))</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chains</span><span class="p">)):</span>
        <span class="n">iact</span> <span class="o">=</span> <span class="n">find_eautocorr</span><span class="p">(</span><span class="n">chains</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">stride</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IACT: &quot;</span><span class="p">,</span> <span class="n">iact</span><span class="p">,</span> <span class="n">chainsname</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">row_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">iact</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">chainsname</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Split-Rhat: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">meanchains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">varchains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="mf">0.975</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="mf">0.025</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mean_rhat</span> <span class="o">=</span> <span class="n">bulk_split_rhat</span><span class="p">(</span><span class="n">meanchains</span><span class="p">)</span>
    <span class="n">var_rhat</span> <span class="o">=</span> <span class="n">bulk_split_rhat</span><span class="p">(</span><span class="n">varchains</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bulk Rhat median: &quot;</span><span class="p">,</span> <span class="n">mean_rhat</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bulk Rhat 0.95 quantile: &quot;</span><span class="p">,</span> <span class="n">var_rhat</span><span class="p">)</span>
    <span class="n">row_fmt</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&gt;15}</span><span class="s2">&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">mean_rhat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; </span><span class="si">{:&lt;25}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">row_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mean_rhat</span><span class="p">,</span><span class="mi">6</span><span class="p">)),</span> <span class="s2">&quot;median&quot;</span><span class="p">))</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">row_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">var_rhat</span><span class="p">,</span><span class="mi">6</span><span class="p">)),</span> <span class="s2">&quot;quantile&quot;</span><span class="p">))</span>
    <span class="n">io</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">iact</span><span class="p">,</span> <span class="n">mean_rhat</span><span class="p">,</span> <span class="n">var_rhat</span></div>





</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Themis Development Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0+untagged.178.gc5e8489.dirty',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            LINK_SUFFIX:'.html', 
            HAS_SOURCE: 'true'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>